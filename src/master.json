{"slots":{"0":{"name":"screen","type":{"events":[],"methods":[]}},"1":{"name":"_databank","type":{"events":[],"methods":[]}},"2":{"name":"emitter","type":{"events":[],"methods":[]}},"3":{"name":"receiver","type":{"events":[],"methods":[]}},"4":{"name":"_databank1","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-5":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"system.print(\"Emitted on \" .. channel .. \"|\" .. message)","filter":{"args":[{"variable":"*"},{"variable":"*"}],"signature":"onSent(channel,message)","slotKey":"2"},"key":"0"},{"code":"system.print(\"Recieved on \" .. channel .. \" - \" .. message)\nmaster:onReceived(channel, message)","filter":{"args":[{"variable":"*"},{"variable":"*"}],"signature":"onReceived(channel,message)","slotKey":"3"},"key":"1"},{"code":"master = EchoCastMaster:new()\nmaster:clearDB()\nmaster:addRequest(\"req1\", \"res1\")\nmaster:addRequest(\"req2\", \"res2\")\nmaster:onUpdate()\nunit.setTimer(\"update\", 0.1)","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"2"},{"code":"master:onUpdate()","filter":{"args":[{"value":"update"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"3"},{"code":"function drawProgress(label, data, progress, maxProgress)\n    return [[\nfunction drawProgressBar(options)\n    local screenWidth, screenHeight = getResolution()\n    local progressBarWidth = screenWidth * 0.8\n    local progressBarHeight = 30\n    local progressBarX = (screenWidth - progressBarWidth) / 2\n    local progressBarY = screenHeight / 2 - progressBarHeight / 2\n    local progressLayer = createLayer()\n    local textLayer = createLayer()\n\n    setNextFillColor(progressLayer, options.backgroundColor[1], options.backgroundColor[2], options.backgroundColor[3], options.backgroundColor[4])\n    addBox(progressLayer, progressBarX, progressBarY, progressBarWidth, progressBarHeight)\n\n    local filledWidth = (options.progress / options.maxProgress) * progressBarWidth\n\n    setNextFillColor(progressLayer, options.fillColor[1], options.fillColor[2], options.fillColor[3], options.fillColor[4])\n    addBox(progressLayer, progressBarX, progressBarY, filledWidth, progressBarHeight)\n\n    drawProgressText(textLayer, options, progressBarX, progressBarWidth, progressBarY, progressBarHeight)\n    drawLabel(textLayer, options, screenHeight, screenWidth, progressBarHeight)\n    drawCoordinates(textLayer, options, screenHeight, screenWidth, progressBarHeight)\n    drawData(textLayer, options, screenHeight, screenWidth, progressBarHeight)\nend\n\nfunction drawProgressText(layer, options, progressBarX, progressBarWidth, progressBarY, progressBarHeight)\n    local progressLayer = createLayer()\n    local progressPercentage = math.floor((options.progress / options.maxProgress) * 100)\n    local progressText = tostring(progressPercentage) .. \"%\"\n\n    local font = loadFont(options.progressFont, options.progressFontSize)\n    setNextFillColor(layer, options.progressPercentageColor[1], options.progressPercentageColor[2], options.progressPercentageColor[3], options.progressPercentageColor[4])\n    setNextTextAlign(layer, AlignH_Center, AlignV_Middle)\n    addText(layer, font, progressText, progressBarX + progressBarWidth / 2, progressBarY + progressBarHeight / 2)\nend\n\nfunction drawLabel(layer, options, screenHeight, screenWidth, progressBarHeight)\n    local font = loadFont(options.labelFont, options.labelFontSize)\n    setNextFillColor(layer, options.textColor[1], options.textColor[2], options.textColor[3], options.textColor[4])\n    setNextTextAlign(layer, AlignH_Center, AlignV_Middle)\n    addText(layer, font, options.label, screenWidth / 2, screenHeight / 2 - progressBarHeight * 2)\nend\n\nfunction drawCoordinates(layer, options, screenHeight, screenWidth, progressBarHeight)\n    local font = loadFont(options.coordinatesFont, options.coordinatesFontSize)\n    setNextFillColor(layer, options.textColor[1], options.textColor[2], options.textColor[3], options.textColor[4])\n    setNextTextAlign(layer, AlignH_Center, AlignV_Middle)\n    addText(layer, font, options.progress .. \"/\" .. options.maxProgress, screenWidth / 2, screenHeight / 2 + progressBarHeight * 2)\nend\n\nfunction drawData(layer, options, screenHeight, screenWidth, progressBarHeight)\n    local subData = string.sub(options.data, 1, 75) .. \"...\"\n    local font = loadFont(options.dataFont, options.dataFontSize)\n    setNextFillColor(layer, options.textColor[1], options.textColor[2], options.textColor[3], options.textColor[4])\n    setNextTextAlign(layer, AlignH_Center, AlignV_Middle)\n    addText(layer, font, subData, screenWidth / 2, screenHeight / 2 + progressBarHeight * 3)\nend\n\nlocal options = {\n        label = ']] .. label .. [[',\n        data = ']] .. data .. [[',\n        progress = ]] .. progress .. [[,\n        maxProgress = ]] .. maxProgress .. [[,\n        backgroundColor = {1, 1, 1, 0.2},\n        fillColor = {1, 1, 1, 1},\n        textColor = {1, 1, 1, 1},\n        labelColor = {0/255, 255/255, 0/255, 1},\n        progressPercentageColor = {0/255, 0/255, 0/255, 1},\n        labelFont = \"RobotoMono\",\n        labelFontSize = 24,\n        progressFont = \"RobotoMono\",\n        progressFontSize = 14,\n        dataFont = \"RobotoMono\",\n        dataFontSize = 14,\n        coordinatesFont = \"RobotoMono\",\n        coordinatesFontSize = 18,\n    }\ndrawProgressBar(options)\n]]\nend\n\nfunction drawText(data)\n    return [[\nfunction getTextWidth(font, text)\n  local fontSize = getFontSize(font)\n  local charWidth = fontSize / 2\n  return charWidth * string.len(text)\nend\n    \nfunction wrapText(text, font, width)\n  local charWidth = getFontSize(font) / 1.5\n  local maxCharsPerLine = math.floor(width / charWidth)\n\n  local lines = {}\n  for i = 1, #text, maxCharsPerLine do\n    local line = text:sub(i, i + maxCharsPerLine - 1)\n    table.insert(lines, line)\n  end\n\n  return lines\nend\n\nlocal layer = createLayer()\nlocal screenWidth, screenHeight = getResolution()\nlocal data = ']] .. data .. [['\nlocal fontWidth = 12\nlocal font = loadFont(\"RobotoMono\", fontWidth)\nlocal wrappedLines = wrapText(data, font, screenWidth)\nlocal startY = 30\nlocal lineHeight = fontWidth * 1.4\n\nfor i, line in ipairs(wrappedLines) do\n  local yPos = startY + (i - 1) * lineHeight\n  setNextTextAlign(layer, AlignH_Center, AlignV_Middle)\n  addText(layer, font, line, screenWidth / 2, yPos)\nend\n]]\nend\n","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"4"},{"code":"Util = {}\nlocal concat = table.concat\nlocal sFormat=string.format\n\nfunction Util.getUnits(isSlave)\n    local emitter, databank, receiver\n    for key, value in pairs(unit) do\n        if type(value) == \"table\" and type(value.export) == \"table\" then\n            if value.getClass then\n                if value.getClass() == \"EmitterUnit\" then\n                    emitter = value\n                elseif value.getClass() == \"ReceiverUnit\" then\n                    receiver = value\n                elseif value.getClass() == \"DataBankUnit\" then\n                        databank = value\n                end\n            end\n        end\n    end\n    if databank == nil then\n        system.print(\"No databank found\")\n    end\n    if emitter == nil then\n        system.print(\"No emitter found\")\n    end\n    if receiver == nil and not isSlave then\n        system.print(\"No receiver found\")\n    end\n    if not (databank and emitter) or (receiver == nil and not isSlave) then\n        system.print(\"Deactivating PB. Please connect the given units.\")\n        unit.exit()\n      end\n    return databank, emitter, receiver\nend\n\nlocal function internalSerialize(table, tC, t)\n    t[tC] = \"{\"\n    tC = tC + 1\n    if #table == 0 then\n        local hasValue = false\n        for key, value in pairs(table) do\n            hasValue = true\n            local keyType = type(key)\n            if keyType == \"string\" then\n                t[tC] = sFormat(\"[%q]=\", key)\n            elseif keyType == \"number\" then\n                t[tC] = \"[\" .. key .. \"]=\"\n            elseif keyType == \"boolean\" then\n                t[tC] = \"[\" .. tostring(key) .. \"]=\"\n            else\n                t[tC] = \"notsupported=\"\n            end\n            tC = tC + 1\n\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = sFormat(\"%q\", value)\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        if hasValue then\n            tC = tC - 1\n        end\n    else\n        for i = 1, #table do\n            local value = table[i]\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = sFormat(\"%q\", value)\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        tC = tC - 1\n    end\n    t[tC] = \"}\"\n    return tC\nend\n\nfunction Util.splitMessage(message, maxLength)\n    local chunks = {}\n\n    local function createChunkString(index, total, content)\n        return index .. \"/\" .. total .. \"/\" .. content\n    end\n\n    local function calculateTotalChunks(messageLength, maxLength)\n        return math.ceil(messageLength / maxLength)\n    end\n\n    local messageLength = #message\n    local totalChunks = calculateTotalChunks(messageLength, maxLength)\n\n    local chunkStart = 1\n    for i = 1, totalChunks do\n        local chunkEnd = math.min(chunkStart + maxLength - 1, messageLength)\n        local chunk = message:sub(chunkStart, chunkEnd)\n        table.insert(chunks, createChunkString(i, totalChunks, chunk))\n        chunkStart = chunkEnd + 1\n    end\n\n    return chunks\nend\n\nfunction Util.stringify(value)\n    local t = {}\n    local check = type(value)\n\n    if check == \"table\" then\n        internalSerialize(value, 1, t)\n    elseif check == \"string\" then\n        return sFormat(\"%q\", value)\n    elseif check == \"number\" then\n        return value\n    elseif check == \"boolean\" then\n        return tostring(value)\n    else\n        return '\"Not Supported\"'\n    end\n\n    return concat(t)\nend\n\nfunction Util.parse(str)\n    local f, err = load(\"return \" .. str)\n    if f then\n        return f()\n    else\n        error(\"Failed to deserialize string: \" .. err)\n    end\nend","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"5"},{"code":"-- EchoCast\n-- v0.0.1 \n-- April 14 2023\n-- by ML\n\nEchoCast = {}\nEchoCast.__index = EchoCast\n\nEchoCastSlave = setmetatable({}, EchoCast)\nEchoCastSlave.__index = EchoCastSlave\n\nEchoCastMaster = setmetatable({}, EchoCast)\nEchoCastMaster.__index = EchoCastMaster\n\nfunction EchoCast:new(isSlave)\n    local obj = {}\n    setmetatable(obj, EchoCast)\n    obj.database, obj.emitter, obj.receiver = Util.getUnits(isSlave)\n    obj.queue = {}\n    return obj\nend\n\nfunction EchoCast:clearDB()\n    self.database.clear()\nend\n\nfunction EchoCastMaster:new()\n    local obj = EchoCast:new(false)\n    setmetatable(obj, EchoCastMaster)\n    obj.timeout = 5\n    obj.timer = nil\n    obj.startTime = system.getArkTime()\n    obj.tempData = {}\n    obj.currentRequest = nil\n    return obj\nend\n\nfunction EchoCastMaster:addRequest(reqChannel, resChannel, addFirst)\n    local queueItem = {channel = reqChannel, resChannel = resChannel, message = \"ping\"}\n    if addFirst then\n        table.insert(self.queue, 1, queueItem)\n    else\n        table.insert(self.queue, queueItem)\n    end\n    if self.receiver.hasChannel(resChannel) == 0 then\n        local channels = self.receiver.getChannelList()\n        table.insert(channels, resChannel)\n        system.print(\"updated channels! \" .. resChannel)\n        self.receiver.setChannelList(channels)\n    end\nend\n\nfunction EchoCastMaster:processQueue()\n    if not self.currentRequest and #self.queue > 0 then\n        self.currentRequest = table.remove(self.queue, 1)\n        self.emitter.send(self.currentRequest.channel, self.currentRequest.message)\n        self.timer = system.getArkTime()\n    end\nend\n\nfunction EchoCastMaster:onUpdate()\n    if self.currentRequest then\n        local currentTime = system.getArkTime()\n        if currentTime - self.timer >= self.timeout then\n            system.print(\"out of time\")\n            self:addRequest(self.currentRequest.channel, self.currentRequest.resChannel, true)\n            self.currentRequest = nil\n            self.timer = nil\n        end\n    end\n    self:processQueue()\nend\n\nfunction EchoCastMaster:onReceived(channel, message)\n    local responseChannel = self.currentRequest and self.currentRequest.resChannel or nil\n    if responseChannel == channel then\n        system.print(\"onReceived \" .. channel)\n        local chunkIndex, totalChunks, content = message:match(\"^(%d+)/(%d+)/(.*)$\")\n        if chunkIndex and totalChunks then\n            local chunkData = content\n            self.tempData[chunkIndex] = chunkData\n            if tonumber(chunkIndex) == tonumber(totalChunks) then\n                system.print(\"Data fully recieved of \" .. self.currentRequest.channel)\n                system.print(content)\n                local orderedChunks = {}\n                for i = 1, totalChunks do\n                    table.insert(orderedChunks, self.tempData[i])\n                end\n                self.database.setStringValue(channel, table.concat(orderedChunks)) \n                self.tempData = {}\n            elseif tonumber(chunkIndex) < tonumber(totalChunks) then\n                system.print(\"Added new request to \" .. self.currentRequest.channel)\n                self:addRequest(self.currentRequest.channel, channel, true)\n            end\n            self.currentRequest = nil\n            self.timer = nil\n        end\n    end\nend\n\nfunction EchoCastSlave:new()\n    local obj = EchoCast:new(true)\n    setmetatable(obj, EchoCastSlave)\n    obj:loadQueue()\n    return obj\nend\n\nfunction EchoCastSlave:loadQueue()\n    self.queue = {}\n    if self.database.hasKey(\"queue\") == 1 then\n        local savedQueue = self.database.getStringValue(\"queue\")\n        for savedItem in savedQueue:gmatch(\"[^\\n]+\") do\n            system.print(\"insert\")\n            table.insert(self.queue, savedItem)\n        end\n    end\nend\n\nfunction EchoCastSlave:saveQueue()\n    if #self.queue == 0 then\n        self.database.clearValue(\"queue\")\n    else\n        local queue = self.queue\n        self.database.setStringValue(\"queue\", table.concat(queue, \"\\n\"))\n    end\nend\n\nfunction EchoCastSlave:addResponse(resChannel, message)\n    if #self.queue == 0 then\n        --message = Util.stringify(message)\n        local maxChunkSize = 512\n        local headerSize = 6\n        local chunkDataSize = maxChunkSize - headerSize\n        local messageLength = #message\n        local totalChunks = math.ceil(messageLength / chunkDataSize)\n\n        for i = 1, totalChunks do\n            local startIdx = (i - 1) * chunkDataSize + 1\n            local endIdx = math.min(i * chunkDataSize, messageLength)\n            local chunk = message:sub(startIdx, endIdx)\n            local chunkWithHeader = string.format(\"%d/%d/%s\", i, totalChunks, chunk)\n            local queueItem = resChannel .. \"|\" .. chunkWithHeader\n            system.print(chunkWithHeader)\n            table.insert(self.queue, queueItem)\n        end\n        self:saveQueue()\n    end\nend\n\nfunction EchoCastSlave:processQueue()\n    local currentRequest = table.remove(self.queue, 1)\n    local channel, message = currentRequest:match(\"^(.-)|(.*)$\")\n    self.emitter.send(channel, message)\n    self:saveQueue()\nend\n\nfunction EchoCastSlave:onUpdate()\n    self:processQueue()\nend","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"6"}],"methods":[],"events":[]}